% Solve an Input-Output Fitting problem with a Neural Network
% Script generated by Neural Fitting app
% Created 27-Apr-2022 14:45:20
%
% This script assumes these variables are defined:
%
%   input - input data.
%   output - target data.
i =1;
for index =1:1:200
    load ([ 'ResultsHPC=' num2str(index)])
    input (1,i:1:i+12) = hrms ;
    input (2,i) = W1(1);
    input (2,i +1) = W1(2);
    input (2 , i +2) = W1(3);
    input (2 , i +3) = W1(4);
    input (2 , i +4) = W1(5);
    input (2 , i +5) = W1(6);
    input (2 , i +6) = W1(7);
    input (2 , i +7) = W1(8);
    input (2 , i +8) = W1(9);
    input (2 , i +9) = W1(10);
    input (2 , i +10) = W1(11);
    input (2 , i +11) = W1(12);
    input (2 , i +12) = W1(13);
    i = i +13;
    end
    %save ( 'Input_W','input','-v7.3')

i =1;
for index =1:1:200
    load (['ResultsHPC=' num2str(index)])
    output (1 , i ) = preD(1);
    output (1 , i +1) = preD(2);
    output (1 , i +2) = preD(3);
    output (1 , i +3) = preD(4);
    output (1 , i +4) = preD(5);
    output (1 , i +5) = preD(6);
    output (1 , i +6) = preD(7);
    output (1 , i +7) = preD(8);
    output (1 , i +8) = preD(9);
    output (1 , i +9) = preD(10);
    output (1 , i +10) = preD(11);
    output (1 , i +11) = preD(12);
    output (1 , i +12) = preD(13);
    output (2 , i ) = sepD(1);
    output (2 , i +1) = sepD(2);
    output (2 , i +2) = sepD(3);
    output (2 , i +3) = sepD(4);
    output (2 , i +4) = sepD(5);
    output (2 , i +5) = sepD(6);
    output (2 , i +6) = sepD(7);
    output (2 , i +7) = sepD(8);
    output (2 , i +8) = sepD(9);
    output (2 , i +9) = sepD(10);
    output (2 , i +10) = sepD(11);
    output (2 , i +11) = sepD(12);
    output (2 , i +12) = sepD(13);
    output (3 , i ) = Contact_ratio(1);
    output (3 , i +1) = Contact_ratio(2);
    output (3 , i +2) = Contact_ratio(3);
    output (3 , i +3) = Contact_ratio(4);
    output (3 , i +4) = Contact_ratio(5);
    output (3 , i +5) = Contact_ratio(6);
    output (3 , i +6) = Contact_ratio(7);
    output (3 , i +7) = Contact_ratio(8);
    output (3 , i +8) = Contact_ratio(9);
    output (3 , i +9) = Contact_ratio(10);
    output (3 , i +10) = Contact_ratio(11);
    output (3 , i +11) = Contact_ratio(12);
    output (3 , i +12) = Contact_ratio(13);
    i = i +13;
    end
    %save ( 'Output _W', 'output' , '-v7.3')
x = input;
t = output;
% Check dimensions of the input and output data
inputSize = size(input);
outputSize = size(output);

disp(['Input size: ', mat2str(inputSize)])
disp(['Output size: ', mat2str(outputSize)])

% Number of samples should match
numSamplesInput = inputSize(2);
numSamplesOutput = outputSize(2);

% Find the minimum number of samples between input and output
numSamples = min(numSamplesInput, numSamplesOutput);

% Trim the input and output data to have the same number of samples
inputTrimmed = input(:, 1:numSamples);
outputTrimmed = output(:, 1:numSamples);

% Reshape the input data to fit the CNN input format
inputReshaped = reshape(inputTrimmed, [2, 1, 1, numSamples]);

% Transpose the output data to match the expected format
outputTransposed = outputTrimmed';

% Ensure the outputTransposed has the correct dimensions
if size(outputTransposed, 1) ~= numSamples
    error('Number of samples in transposed output data must match the input data.');
end

% Define the layers of the CNN
layers = [
    imageInputLayer([2 1 1])
    convolution2dLayer([2 1], 8, 'Padding', 'same')
    reluLayer()
    fullyConnectedLayer(10)
    reluLayer()
    fullyConnectedLayer(outputSize(1))
    regressionLayer()
];

% Specify training options
options = trainingOptions('adam', ...
    'InitialLearnRate', 0.001, ...
    'MaxEpochs', 1000, ...
    'MiniBatchSize', 64, ...
    'Shuffle', 'every-epoch', ...
    'ValidationData', {inputReshaped, outputTransposed}, ...
    'ValidationFrequency', 30, ...
    'Plots', 'training-progress', ...
    'Verbose', false);

% Train the network
net = trainNetwork(inputReshaped, outputTransposed, layers, options);

% Test the Network
predictions = predict(net, inputReshaped);
errors = predictions - outputTransposed;
performance = mse(errors);

% Display performance
disp(['Mean Squared Error: ', num2str(performance)])

% Plot the actual vs predicted contact area ratio (assuming it is in the 3rd row)
actualContactRatio = outputTrimmed(3, :);
predictedContactRatio = predictions(:, 3);

figure;
scatter(actualContactRatio, predictedContactRatio, 'b');
hold on;
plot([min(actualContactRatio), max(actualContactRatio)], ...
     [min(actualContactRatio), max(actualContactRatio)], 'r--');
legend('Predicted vs Actual', 'Perfect Performance (y = x)');
xlabel('Actual Contact Ratio');
ylabel('Predicted Contact Ratio');
title('Actual vs Predicted Contact Area Ratio');
grid on;

% Export scatter plot data to CSV
csvData = table(actualContactRatio', predictedContactRatio', ...
    'VariableNames', {'ActualContactRatio', 'PredictedContactRatio'});
writetable(csvData, 'ContactRatioScatterPlotData.csv');

% Plot MSE over epochs
trainingInfo = net.Layers(end).TrainingInfo;
figure;
plot(trainingInfo.TrainingLoss, 'b');
hold on;
plot(trainingInfo.ValidationLoss, 'r--');
legend('Training MSE', 'Validation MSE');
xlabel('Epoch');
ylabel('Mean Squared Error');
title('Training and Validation MSE Over Epochs');
grid on;

% Save the trained network
save('Trained_CNN_Net', 'net');